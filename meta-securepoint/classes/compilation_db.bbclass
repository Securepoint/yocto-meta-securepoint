# use CMAKE to generate a CompilationDB for use with YouCompleteMe (YCM)
#
# Solves the problem of ugly-to-configure local builds by replacing local
# include paths with their actual source location (instead of
# somewhere-in-the-yocto-build folder), while 
# keeping the absolute paths into the yocto build to external includes
#
# To use with YCM, add a .ycm_extra_conf.py somewhere and let YCM use it
#   (let g:ycm_global_ycm_extra_conf = '/path/to/.ycm_extra_conf.py')
#
# Within, change the following line:
#   compilation_database_folder = None
#   to 
#   compilation_database_folder = os.getcwd()
#
# global configuration via conf/local.conf
# GEN_COMPILATION_DB_PATH_BASE: 
#   used to create a target directory (${GEN_COMPILATION_DB_PATH_BASE}/${PN})
#   for the generated compile_commands.json if no GEN_COMPILATION_DB_PATH is
#   specified for the recipe, e.g., for fwserver there needs to be a
#   folder ${GEN_COMPILATION_DB_PATH_BASE}/fwserver
# 
# per recipe configuration (in meta-local/<PN>_%.bbappend:
# add 'inherit compilation_db'
# GEN_COMPILATION_DB_PATH: individual target path for recipe
#   --> (overwrite usage of ${GEN_COMPILATION_DB_PATH_BASE}/${PN})
# GEN_COMPILATION_ADD: a whitespace-separated list of paths; for each entry
#   "cp ${B}/${PN}/${entry} ${GEN_COMPILATION_DB_PATH}/${PN}/${entry}"
#   is executed; used to fix errors of YCM clang completer about missing
#   includes that are generated by cmake during the build process -- those
#   are copied form the 'build' (${B})
#   path of the bitbake build
# The following may be useful to translate paths from a build within a
# docker container to a host system where the code is; e.g., assume, the
# fwserver repo's parent dir is mounted into the container as
# -v /home/<user>/sp_git:/home/yocto/yocto/dst/sp_git and the output build dir
# as -v ~/yocto_docker_warrior_out:/home/yocto/yocto/dst, this can be used
# to replace /home/yocto/yocto/dst/sp_git with /home/<user>/sp_git and
# /home/yocto/yocto/dst with ~/yocto_docker_warrior_out. PROJECT_PREFIX is
# replaced before SYSROOT_PREFIX because it is expected to be the longer path
#
# PROJECT_PREFIX_REPLACE_SRC: replace this path by PROJECT_PREFIX_REPLACE_DST
#   exectued before replacing sysroot
# PROJECT_PREFIX_REPLACE_DST: replaces PROJECT_PREFIX_REPLACE_SRC if both set
#   executed before replacing sysroot
# SYSROOT_PREFIX_REPLACE_SRC: replace this path by SYSROOT_PREFIX_REPLACE_DST
# SYSROOT_PREFIX_REPLACE_DST: replaces SYSROOT_PREFIX_REPLACE_SRC in compile_commands.json

EXTRA_OECMAKE:append ="  -DCMAKE_EXPORT_COMPILE_COMMANDS=1"

def sed_replace(file, search_pattern, replace_pattern):
    import subprocess
    subprocess.call(["sed", "-i", "s|{0}|{1}|g".format(search_pattern, replace_pattern), file])

python do_compilation_db() {
    import shutil
    import sys
    import os
    import errno

    project_replace_src=d.getVar('PROJECT_PREFIX_REPLACE_SRC')
    project_replcae_dst=d.getVar('PROJECT_PREFIX_REPLACE_DST')
    sysroot_replace_src=d.getVar('SYSROOT_PREFIX_REPLACE_SRC')
    sysroot_replace_dst=d.getVar('SYSROOT_PREFIX_REPLACE_DST')
    target = d.getVar('GEN_COMPILATION_DB_PATH')
    if target is None:
        base_path = d.getVar('GEN_COMPILATION_DB_PATH_BASE')
        if base_path is not None:
            target = "{0}/{1}".format(base_path, d.getVar('PN', expand=True))
        else:
            bb.plain("No target directory via GEN_COPMILATION_DB_PATH and no default base bath via GEN_COMPILATION_DB_BASE_PATH given; aborting...")
            return
        
    cmake_compile_db_file="compile_commands.json"
    y_builddir = d.getVar('B', expand=True)
    y_srcdir = d.getVar('S', expand=True)

    y_cc_file = "{0}/{1}".format(y_builddir, cmake_compile_db_file)
    t_cc_file = "{0}/{1}".format(target, cmake_compile_db_file)
    
    # copy compilation database
    try:
        shutil.copy2(y_cc_file, t_cc_file)
    except:
        bb.plain("error copying compilation db {0}: {1}".format(y_cc_file, sys.exc_info()[0]))
    # replace bitbake project locations (src and build) with project location
    sed_replace(t_cc_file, y_builddir, target)
    sed_replace(t_cc_file, y_srcdir, target)

    if project_replace_src is not None and project_replcae_dst is not None:
      sed_replace(t_cc_file, project_replace_src, project_replcae_dst)
    if sysroot_replace_src is not None and sysroot_replace_dst is not None:
      sed_replace(t_cc_file, sysroot_replace_src, sysroot_replace_dst)

    # check if additional (generated headers, e.g.)  for copying are defined 
    additional_files = d.getVar("GEN_COMPILATION_ADD")
    bb.plain("additional files to copy: {0}".format(additional_files))
    if additional_files is not None:
        for file in additional_files.split():
            try:
                target_dir = os.path.dirname("{0}/{1}".format(target, file))
                os.makedirs(target_dir)
            except OSError as e:
                if e.errno == e.errno == errno.EEXIST and os.path.isdir(target_dir):
                    pass
                else:
                    raise
            try:
                bb.plain("copy: {0}/{1} to {2}/{1}".format(y_builddir, file, target))
                shutil.copy2("{0}/{1}".format(y_builddir, file), "{0}/{1}".format(target, file))
            except:
                bb.plain("copy failed: {0}".format(sys.exc_info()[0]))
} 

addtask compilation_db after do_compile before do_build

