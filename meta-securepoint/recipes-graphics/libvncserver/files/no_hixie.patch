diff --git a/libvncserver/Makefile.am b/libvncserver/Makefile.am
index e25784b..2f3eba0 100644
--- a/libvncserver/Makefile.am
+++ b/libvncserver/Makefile.am
@@ -26,7 +26,7 @@ WEBSOCKETSSSLSRCS = rfbssl_none.c rfbcrypto_included.c ../common/md5.c ../common
 endif
 endif
 
-WEBSOCKETSSRCS = websockets.c $(WEBSOCKETSSSLSRCS)
+WEBSOCKETSSRCS = websockets.c ws_decode.c $(WEBSOCKETSSSLSRCS)
 endif
 
 includedir=$(prefix)/include/rfb
diff --git a/libvncserver/websockets.c b/libvncserver/websockets.c
index bdec8f3..58fbb92 100644
--- a/libvncserver/websockets.c
+++ b/libvncserver/websockets.c
@@ -34,10 +34,6 @@
 /* errno */
 #include <errno.h>
 
-#ifndef _MSC_VER
-#include <resolv.h> /* __b64_ntop */
-#endif
-
 #ifdef LIBVNCSERVER_HAVE_ENDIAN_H
 #include <endian.h>
 #elif LIBVNCSERVER_HAVE_SYS_ENDIAN_H
@@ -53,20 +49,8 @@
 #include "rfb/rfbconfig.h"
 #include "rfbssl.h"
 #include "rfbcrypto.h"
+#include "ws_decode.h"
 
-#define WS_NTOH64(n) htobe64(n)
-#define WS_NTOH32(n) htobe32(n)
-#define WS_NTOH16(n) htobe16(n)
-#define WS_HTON64(n) htobe64(n)
-#define WS_HTON16(n) htobe16(n)
-
-#define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)
-#define WSHLENMAX 14  /* 2 + sizeof(uint64_t) + sizeof(uint32_t) */
-
-enum {
-  WEBSOCKETS_VERSION_HIXIE,
-  WEBSOCKETS_VERSION_HYBI
-};
 
 #if 0
 #include <sys/syscall.h>
@@ -75,59 +59,6 @@ static int gettid() {
 }
 #endif
 
-typedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);
-typedef int (*wsDecodeFunc)(rfbClientPtr cl, char *dst, int len);
-
-typedef struct ws_ctx_s {
-    char codeBufDecode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */
-	char codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */
-	char readbuf[8192];
-    int readbufstart;
-    int readbuflen;
-    int dblen;
-    char carryBuf[3];                      /* For base64 carry-over */
-    int carrylen;
-    int version;
-    int base64;
-    wsEncodeFunc encode;
-    wsDecodeFunc decode;
-} ws_ctx_t;
-
-typedef union ws_mask_s {
-  char c[4];
-  uint32_t u;
-} ws_mask_t;
-
-/* XXX: The union and the structs do not need to be named.
- *      We are working around a bug present in GCC < 4.6 which prevented
- *      it from recognizing anonymous structs and unions.
- *      See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4784
- */
-typedef struct __attribute__ ((__packed__)) ws_header_s {
-  unsigned char b0;
-  unsigned char b1;
-  union {
-    struct __attribute__ ((__packed__)) {
-      uint16_t l16;
-      ws_mask_t m16;
-    } s16;
-    struct __attribute__ ((__packed__)) {
-      uint64_t l64;
-      ws_mask_t m64;
-    } s64;
-    ws_mask_t m;
-  } u;
-} ws_header_t;
-
-enum
-{
-    WS_OPCODE_CONTINUATION = 0x0,
-    WS_OPCODE_TEXT_FRAME,
-    WS_OPCODE_BINARY_FRAME,
-    WS_OPCODE_CLOSE = 0x8,
-    WS_OPCODE_PING,
-    WS_OPCODE_PONG
-};
 
 #define FLASH_POLICY_RESPONSE "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\" /></cross-domain-policy>\n"
 #define SZ_FLASH_POLICY_RESPONSE 93
@@ -138,14 +69,6 @@ enum
  */
 #define GUID "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
 
-#define SERVER_HANDSHAKE_HIXIE "HTTP/1.1 101 Web Socket Protocol Handshake\r\n\
-Upgrade: WebSocket\r\n\
-Connection: Upgrade\r\n\
-%sWebSocket-Origin: %s\r\n\
-%sWebSocket-Location: %s://%s%s\r\n\
-%sWebSocket-Protocol: %s\r\n\
-\r\n%s"
-
 #define SERVER_HANDSHAKE_HYBI "HTTP/1.1 101 Switching Protocols\r\n\
 Upgrade: websocket\r\n\
 Connection: Upgrade\r\n\
@@ -175,9 +98,9 @@ static rfbBool webSocketsHandshake(rfbClientPtr cl, char *scheme);
 void webSocketsGenMd5(char * target, char *key1, char *key2, char *key3);
 
 static int webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst);
-static int webSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst);
-static int webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len);
-static int webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len);
+
+static int ws_read(void *cl, char *buf, int len);
+
 
 static int
 min (int a, int b) {
@@ -286,8 +209,8 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)
                 rfbLog("webSocketsHandshake: client gone\n");
             else
                 rfbLogPerror("webSocketsHandshake: read");
-            free(response);
-            free(buf);
+                free(response);
+                free(buf);
             return FALSE;
         }
 
@@ -340,24 +263,33 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)
                 /* rfbLog("Got key2: %s\n", key2); */
             /* HyBI */
 
-	    } else if ((strncasecmp("sec-websocket-protocol: ", line, min(llen,24))) == 0) {
+            } else if ((strncasecmp("sec-websocket-protocol: ", line, min(llen,24))) == 0) {
                 protocol = line+24;
                 buf[len-2] = '\0';
                 rfbLog("Got protocol: %s\n", protocol);
             } else if ((strncasecmp("sec-websocket-origin: ", line, min(llen,22))) == 0) {
-		sec_ws_origin = line+22;
+                sec_ws_origin = line+22;
                 buf[len-2] = '\0';
             } else if ((strncasecmp("sec-websocket-key: ", line, min(llen,19))) == 0) {
-		sec_ws_key = line+19;
+                sec_ws_key = line+19;
                 buf[len-2] = '\0';
             } else if ((strncasecmp("sec-websocket-version: ", line, min(llen,23))) == 0) {
-		sec_ws_version = strtol(line+23, NULL, 10);
+                sec_ws_version = strtol(line+23, NULL, 10);
                 buf[len-2] = '\0';
-	    }
+            }
 
             linestart = len;
         }
     }
+    
+    /* older hixie handshake, this could be removed if
+     * a final standard is established -- removed now */
+    if (!sec_ws_version) {
+        rfbErr("Hixie no longer supported\n");
+        free(response);
+        free(buf);
+        return FALSE;
+    } 
 
     if (!(path && host && (origin || sec_ws_origin))) {
         rfbErr("webSocketsHandshake: incomplete client handshake\n");
@@ -367,12 +299,6 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)
     }
 
     if ((protocol) && (strstr(protocol, "binary"))) {
-        if (! sec_ws_version) {
-            rfbErr("webSocketsHandshake: 'binary' protocol not supported with Hixie\n");
-            free(response);
-            free(buf);
-            return FALSE;
-        }
         rfbLog("  - webSocketsHandshake: using binary/raw encoding\n");
         base64 = FALSE;
         protocol = "binary";
@@ -390,32 +316,16 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)
      * Generate the WebSockets server response based on the the headers sent
      * by the client.
      */
+    char accept[B64LEN(SHA1_HASH_SIZE) + 1];
+    rfbLog("  - WebSockets client version hybi-%02d\n", sec_ws_version);
+    webSocketsGenSha1Key(accept, sizeof(accept), sec_ws_key);
 
-    if (sec_ws_version) {
-	char accept[B64LEN(SHA1_HASH_SIZE) + 1];
-	rfbLog("  - WebSockets client version hybi-%02d\n", sec_ws_version);
-	webSocketsGenSha1Key(accept, sizeof(accept), sec_ws_key);
-        if(strlen(protocol) > 0)
-            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
-	                   SERVER_HANDSHAKE_HYBI, accept, protocol);
-        else
-            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
-                           SERVER_HANDSHAKE_HYBI_NO_PROTOCOL, accept);
+    if(strlen(protocol) > 0) {
+        len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
+                 SERVER_HANDSHAKE_HYBI, accept, protocol);
     } else {
-	/* older hixie handshake, this could be removed if
-	 * a final standard is established */
-	if (!(key1 && key2 && key3)) {
-	    rfbLog("  - WebSockets client version hixie-75\n");
-	    prefix[0] = '\0';
-	    trailer[0] = '\0';
-	} else {
-	    rfbLog("  - WebSockets client version hixie-76\n");
-	    snprintf(prefix, 5, "Sec-");
-	    webSocketsGenMd5(trailer, key1, key2, key3);
-	}
-	len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
-		 SERVER_HANDSHAKE_HIXIE, prefix, origin, prefix, scheme,
-		 host, path, prefix, protocol, trailer);
+        len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,
+                       SERVER_HANDSHAKE_HYBI_NO_PROTOCOL, accept);
     }
 
     if (rfbWriteExact(cl, response, len) < 0) {
@@ -428,22 +338,17 @@ webSocketsHandshake(rfbClientPtr cl, char *scheme)
     free(response);
     free(buf);
 
-
     wsctx = calloc(1, sizeof(ws_ctx_t));
-    if (sec_ws_version) {
-	wsctx->version = WEBSOCKETS_VERSION_HYBI;
-	wsctx->encode = webSocketsEncodeHybi;
-	wsctx->decode = webSocketsDecodeHybi;
-    } else {
-	wsctx->version = WEBSOCKETS_VERSION_HIXIE;
-	wsctx->encode = webSocketsEncodeHixie;
-	wsctx->decode = webSocketsDecodeHixie;
-    }
+    wsctx->version = WEBSOCKETS_VERSION_HYBI;
+    wsctx->encode = webSocketsEncodeHybi;
+    wsctx->decode = webSocketsDecodeHybi;
+    wsctx->ctxInfo.readFunc = ws_read;
     wsctx->base64 = base64;
+    hybiDecodeCleanup(wsctx);
     cl->wsctx = (wsCtx *)wsctx;
     return TRUE;
 }
- 
+
 void
 webSocketsGenMd5(char * target, char *key1, char *key2, char *key3)
 {
@@ -494,289 +399,20 @@ webSocketsGenMd5(char * target, char *key1, char *key2, char *key3)
     return;
 }
 
-static int
-webSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst)
-{
-    int sz = 0;
-    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
-
-    wsctx->codeBufEncode[sz++] = '\x00';
-    len = __b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode+sz, sizeof(wsctx->codeBufEncode) - (sz + 1));
-    if (len < 0) {
-        return len;
-    }
-    sz += len;
-
-    wsctx->codeBufEncode[sz++] = '\xff';
-    *dst = wsctx->codeBufEncode;
-    return sz;
-}
 
 static int
-ws_read(rfbClientPtr cl, char *buf, int len)
+ws_read(void *ctxPtr, char *buf, int len)
 {
     int n;
+    rfbClientPtr cl = ctxPtr;
     if (cl->sslctx) {
-	n = rfbssl_read(cl, buf, len);
+        n = rfbssl_read(cl, buf, len);
     } else {
-	n = read(cl->sock, buf, len);
+        n = read(cl->sock, buf, len);
     }
     return n;
 }
 
-static int
-ws_peek(rfbClientPtr cl, char *buf, int len)
-{
-    int n;
-    if (cl->sslctx) {
-	n = rfbssl_peek(cl, buf, len);
-    } else {
-	while (-1 == (n = recv(cl->sock, buf, len, MSG_PEEK))) {
-	    if (errno != EAGAIN)
-		break;
-	}
-    }
-    return n;
-}
-
-static int
-webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len)
-{
-    int retlen = 0, n, i, avail, modlen, needlen;
-    char *buf, *end = NULL;
-    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
-
-    buf = wsctx->codeBufDecode;
-
-    n = ws_peek(cl, buf, len*2+2);
-
-    if (n <= 0) {
-        /* save errno because rfbErr() will tamper it */
-        int olderrno = errno;
-        rfbErr("%s: peek (%d) %m\n", __func__, errno);
-        errno = olderrno;
-        return n;
-    }
-
-
-    /* Base64 encoded WebSockets stream */
-
-    if (buf[0] == '\xff') {
-        i = ws_read(cl, buf, 1); /* Consume marker */
-        buf++;
-        n--;
-    }
-    if (n == 0) {
-        errno = EAGAIN;
-        return -1;
-    }
-    if (buf[0] == '\x00') {
-        i = ws_read(cl, buf, 1); /* Consume marker */
-        buf++;
-        n--;
-    }
-    if (n == 0) {
-        errno = EAGAIN;
-        return -1;
-    }
-
-    /* end = memchr(buf, '\xff', len*2+2); */
-    end = memchr(buf, '\xff', n);
-    if (!end) {
-        end = buf + n;
-    }
-    avail = end - buf;
-
-    len -= wsctx->carrylen;
-
-    /* Determine how much base64 data we need */
-    modlen = len + (len+2)/3;
-    needlen = modlen;
-    if (needlen % 4) {
-        needlen += 4 - (needlen % 4);
-    }
-
-    if (needlen > avail) {
-        /* rfbLog("Waiting for more base64 data\n"); */
-        errno = EAGAIN;
-        return -1;
-    }
-
-    /* Any carryover from previous decode */
-    for (i=0; i < wsctx->carrylen; i++) {
-        /* rfbLog("Adding carryover %d\n", wsctx->carryBuf[i]); */
-        dst[i] = wsctx->carryBuf[i];
-        retlen += 1;
-    }
-
-    /* Decode the rest of what we need */
-    buf[needlen] = '\x00';  /* Replace end marker with end of string */
-    /* rfbLog("buf: %s\n", buf); */
-    n = __b64_pton(buf, (unsigned char *)dst+retlen, 2+len);
-    if (n < len) {
-        rfbErr("Base64 decode error\n");
-        errno = EIO;
-        return -1;
-    }
-    retlen += n;
-
-    /* Consume the data from socket */
-    i = ws_read(cl, buf, needlen);
-
-    wsctx->carrylen = n - len;
-    retlen -= wsctx->carrylen;
-    for (i=0; i < wsctx->carrylen; i++) {
-        /* rfbLog("Saving carryover %d\n", dst[retlen + i]); */
-        wsctx->carryBuf[i] = dst[retlen + i];
-    }
-
-    /* rfbLog("<< webSocketsDecode, retlen: %d\n", retlen); */
-    return retlen;
-}
-
-static int
-webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)
-{
-    char *buf, *payload;
-    uint32_t *payload32;
-    int ret = -1, result = -1;
-    int total = 0;
-    ws_mask_t mask;
-    ws_header_t *header;
-    int i;
-    unsigned char opcode;
-    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
-    int flength, fhlen;
-    /* int fin; */ /* not used atm */ 
-
-    /* rfbLog(" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\n", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */
-
-    if (wsctx->readbuflen) {
-      /* simply return what we have */
-      if (wsctx->readbuflen > len) {
-	memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);
-	result = len;
-	wsctx->readbuflen -= len;
-	wsctx->readbufstart += len;
-      } else {
-	memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);
-	result = wsctx->readbuflen;
-	wsctx->readbuflen = 0;
-	wsctx->readbufstart = 0;
-      }
-      goto spor;
-    }
-
-    buf = wsctx->codeBufDecode;
-    header = (ws_header_t *)wsctx->codeBufDecode;
-
-    ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);
-
-    if (ret < 2) {
-        /* save errno because rfbErr() will tamper it */
-        if (-1 == ret) {
-            int olderrno = errno;
-            rfbErr("%s: peek; %m\n", __func__);
-            errno = olderrno;
-        } else if (0 == ret) {
-            result = 0;
-        } else {
-            errno = EAGAIN;
-        }
-        goto spor;
-    }
-
-    opcode = header->b0 & 0x0f;
-    /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */
-    flength = header->b1 & 0x7f;
-
-    /*
-     * 4.3. Client-to-Server Masking
-     *
-     * The client MUST mask all frames sent to the server.  A server MUST
-     * close the connection upon receiving a frame with the MASK bit set to 0.
-    **/
-    if (!(header->b1 & 0x80)) {
-	rfbErr("%s: got frame without mask\n", __func__, ret);
-	errno = EIO;
-	goto spor;
-    }
-
-    if (flength < 126) {
-	fhlen = 2;
-	mask = header->u.m;
-    } else if (flength == 126 && 4 <= ret) {
-	flength = WS_NTOH16(header->u.s16.l16);
-	fhlen = 4;
-	mask = header->u.s16.m16;
-    } else if (flength == 127 && 10 <= ret) {
-	flength = WS_NTOH64(header->u.s64.l64);
-	fhlen = 10;
-	mask = header->u.s64.m64;
-    } else {
-      /* Incomplete frame header */
-      rfbErr("%s: incomplete frame header\n", __func__, ret);
-      errno = EIO;
-      goto spor;
-    }
-
-    /* absolute length of frame */
-    total = fhlen + flength + 4;
-    payload = buf + fhlen + 4; /* header length + mask */
-
-    if (-1 == (ret = ws_read(cl, buf, total))) {
-      int olderrno = errno;
-      rfbErr("%s: read; %m", __func__);
-      errno = olderrno;
-      return ret;
-    } else if (ret < total) {
-      /* GT TODO: hmm? */
-      rfbLog("%s: read; got partial data\n", __func__);
-    } else {
-      buf[ret] = '\0';
-    }
-
-    /* process 1 frame (32 bit op) */
-    payload32 = (uint32_t *)payload;
-    for (i = 0; i < flength / 4; i++) {
-	payload32[i] ^= mask.u;
-    }
-    /* process the remaining bytes (if any) */
-    for (i*=4; i < flength; i++) {
-	payload[i] ^= mask.c[i % 4];
-    }
-
-    switch (opcode) {
-      case WS_OPCODE_CLOSE:
-	rfbLog("got closure, reason %d\n", WS_NTOH16(((uint16_t *)payload)[0]));
-	errno = ECONNRESET;
-	break;
-      case WS_OPCODE_TEXT_FRAME:
-	if (-1 == (flength = __b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {
-	  rfbErr("%s: Base64 decode error; %m\n", __func__);
-	  break;
-	}
-	payload = wsctx->codeBufDecode;
-	/* fall through */
-      case WS_OPCODE_BINARY_FRAME:
-	if (flength > len) {
-	  memcpy(wsctx->readbuf, payload + len, flength - len);
-	  wsctx->readbufstart = 0;
-	  wsctx->readbuflen = flength - len;
-	  flength = len;
-	}
-	memcpy(dst, payload, flength);
-	result = flength;
-	break;
-      default:
-	rfbErr("%s: unhandled opcode %d, b0: %02x, b1: %02x\n", __func__, (int)opcode, header->b0, header->b1);
-    }
-
-    /* single point of return, if someone has questions :-) */
-spor:
-    /* rfbLog("%s: ret: %d/%d\n", __func__, result, len); */
-    return result;
-}
 
 static int
 webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)
@@ -803,12 +439,12 @@ webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)
     header = (ws_header_t *)wsctx->codeBufEncode;
 
     if (wsctx->base64) {
-	opcode = WS_OPCODE_TEXT_FRAME;
-	/* calculate the resulting size */
-	blen = B64LEN(len);
+        opcode = WS_OPCODE_TEXT_FRAME;
+        /* calculate the resulting size */
+        blen = B64LEN(len);
     } else {
-	opcode = WS_OPCODE_BINARY_FRAME;
-	blen = len;
+        opcode = WS_OPCODE_BINARY_FRAME;
+        blen = len;
     }
 
     header->b0 = 0x80 | (opcode & 0x0f);
@@ -827,15 +463,15 @@ webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)
 
     if (wsctx->base64) {
         if (-1 == (ret = __b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode + sz, sizeof(wsctx->codeBufEncode) - sz))) {
-	  rfbErr("%s: Base 64 encode failed\n", __func__);
-	} else {
-	  if (ret != blen)
-	    rfbErr("%s: Base 64 encode; something weird happened\n", __func__);
-	  ret += sz;
-	}
+            rfbErr("%s: Base 64 encode failed\n", __func__);
+        } else {
+          if (ret != blen)
+            rfbErr("%s: Base 64 encode; something weird happened\n", __func__);
+          ret += sz;
+        }
     } else {
-      memcpy(wsctx->codeBufEncode + sz, src, len);
-      ret =  sz + len;
+        memcpy(wsctx->codeBufEncode + sz, src, len);
+        ret =  sz + len;
     }
 
     *dst = wsctx->codeBufEncode;
@@ -846,73 +482,26 @@ webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)
 int
 webSocketsEncode(rfbClientPtr cl, const char *src, int len, char **dst)
 {
-    return ((ws_ctx_t *)cl->wsctx)->encode(cl, src, len, dst);
+    return webSocketsEncodeHybi(cl, src, len, dst);
 }
 
 int
 webSocketsDecode(rfbClientPtr cl, char *dst, int len)
 {
-    return ((ws_ctx_t *)cl->wsctx)->decode(cl, dst, len);
+    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx; 
+    wsctx->ctxInfo.ctxPtr = cl;
+    return webSocketsDecodeHybi(wsctx, dst, len);
 }
 
 
 /* returns TRUE if client sent a close frame or a single 'end of frame'
  * marker was received, FALSE otherwise
  *
- * Note: This is a Hixie-only hack!
+ * Note: This was a Hixie-only hack!
  **/
 rfbBool
 webSocketCheckDisconnect(rfbClientPtr cl)
 {
-    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
-    /* With Base64 encoding we need at least 4 bytes */
-    char peekbuf[4];
-    int n;
-
-    if (wsctx->version == WEBSOCKETS_VERSION_HYBI)
-	return FALSE;
-
-    if (cl->sslctx)
-	n = rfbssl_peek(cl, peekbuf, 4);
-    else
-	n = recv(cl->sock, peekbuf, 4, MSG_PEEK);
-
-    if (n <= 0) {
-	if (n != 0)
-	    rfbErr("%s: peek; %m", __func__);
-	rfbCloseClient(cl);
-	return TRUE;
-    }
-
-    if (peekbuf[0] == '\xff') {
-	int doclose = 0;
-	/* Make sure we don't miss a client disconnect on an end frame
-	 * marker. Because we use a peek buffer in some cases it is not
-	 * applicable to wait for more data per select(). */
-	switch (n) {
-	    case 3:
-		if (peekbuf[1] == '\xff' && peekbuf[2] == '\x00')
-		    doclose = 1;
-		break;
-	    case 2:
-		if (peekbuf[1] == '\x00')
-		    doclose = 1;
-		break;
-	    default:
-		return FALSE;
-	}
-
-	if (cl->sslctx)
-	    n = rfbssl_read(cl, peekbuf, n);
-	else
-	    n = read(cl->sock, peekbuf, n);
-
-	if (doclose) {
-	    rfbErr("%s: websocket close frame received\n", __func__);
-	    rfbCloseClient(cl);
-	}
-	return TRUE;
-    }
     return FALSE;
 }
 
@@ -924,8 +513,8 @@ webSocketsHasDataInBuffer(rfbClientPtr cl)
 {
     ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;
 
-    if (wsctx && wsctx->readbuflen)
-      return TRUE;
+    if (wsctx && wsctx->readlen)
+        return TRUE;
 
     return (cl->sslctx && rfbssl_pending(cl) > 0);
 }
diff --git a/libvncserver/ws_decode.c b/libvncserver/ws_decode.c
new file mode 100644
index 0000000..6afb2b5
--- /dev/null
+++ b/libvncserver/ws_decode.c
@@ -0,0 +1,448 @@
+#include "ws_decode.h"
+
+#include <syslog.h>
+#include <string.h>
+#include <errno.h>
+
+#define WS_HYBI_MASK_LEN 4
+
+
+static int
+hybiRemaining(ws_ctx_t *wsctx)
+{
+  return wsctx->nToRead - wsctx->nReadRaw;
+}
+
+void
+hybiDecodeCleanup(ws_ctx_t *wsctx)
+{
+  wsctx->header.payloadLen = 0;
+  wsctx->header.mask.u = 0;
+  wsctx->nReadRaw = 0;
+  wsctx->nToRead= 0;
+  wsctx->carrylen = 0;
+  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;
+  wsctx->readlen = 0;
+  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;
+  wsctx->writePos = NULL;
+  rfbLog("cleaned up wsctx\n");
+}
+
+/**
+ * Return payload data that has been decoded/unmasked from
+ * a websocket frame.
+ *
+ * @param[out]     dst destination buffer
+ * @param[in]      len bytes to copy to destination buffer
+ * @param[in,out]  wsctx internal state of decoding procedure
+ * @param[out]     number of bytes actually written to dst buffer
+ * @return next hybi decoding state
+ */
+static int
+hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)
+{
+  int nextState = WS_HYBI_STATE_ERR;
+
+  /* if we have something already decoded copy and return */
+  if (wsctx->readlen > 0) {
+    /* simply return what we have */
+    if (wsctx->readlen > len) {
+      rfbLog("copy to %d bytes to dst buffer; readPos=%p, readLen=%d\n", len, wsctx->readPos, wsctx->readlen);
+      memcpy(dst, wsctx->readPos, len);
+      *nWritten = len;
+      wsctx->readlen -= len;
+      wsctx->readPos += len;
+      nextState = WS_HYBI_STATE_DATA_AVAILABLE;
+    } else {
+      rfbLog("copy to %d bytes to dst buffer; readPos=%p, readLen=%d\n", wsctx->readlen, wsctx->readPos, wsctx->readlen);
+      memcpy(dst, wsctx->readPos, wsctx->readlen);
+      *nWritten = wsctx->readlen;
+      wsctx->readlen = 0;
+      wsctx->readPos = NULL;
+      if (hybiRemaining(wsctx) == 0) {
+        nextState = WS_HYBI_STATE_FRAME_COMPLETE;
+      } else {
+        nextState = WS_HYBI_STATE_DATA_NEEDED;
+      }
+    }
+    rfbLog("after copy: readPos=%p, readLen=%d\n", wsctx->readPos, wsctx->readlen);
+  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {
+    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;
+  }
+  return nextState;
+}
+
+/**
+ * Read an RFC 6455 websocket frame (IETF hybi working group).
+ *
+ * Internal state is updated according to bytes received and the
+ * decoding of header information.
+ *
+ * @param[in]   cl client ptr with ptr to raw socket and ws_ctx_t ptr
+ * @param[out]  sockRet emulated recv return value
+ * @return next hybi decoding state; WS_HYBI_STATE_HEADER_PENDING indicates
+ *         that the header was not received completely.
+ */
+static int
+hybiReadHeader(ws_ctx_t *wsctx, int *sockRet)
+{
+  int ret;
+  char *headerDst = wsctx->codeBufDecode + wsctx->nReadRaw;
+  int n = WSHLENMAX - wsctx->nReadRaw;
+
+  rfbLog("header_read to %p with len=%d\n", headerDst, n);
+  //ret = ws_read(cl, headerDst, n);
+  ret = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, headerDst, n);
+  rfbLog("read %d bytes from socket\n", ret);
+  if (ret <= 0) {
+    if (-1 == ret) {
+      /* save errno because rfbErr() will tamper it */
+      int olderrno = errno;
+      rfbErr("%s: read; %s\n", __func__, strerror(errno));
+      errno = olderrno;
+      *sockRet = -1;
+    } else {
+      *sockRet = 0;
+    }
+    return WS_HYBI_STATE_ERR;
+  }
+
+  wsctx->nReadRaw += ret;
+  if (wsctx->nReadRaw < 2) {
+    /* cannot decode header with less than two bytes */
+    errno = EAGAIN;
+    *sockRet = -1;
+    return WS_HYBI_STATE_HEADER_PENDING;
+  }
+
+  /* first two header bytes received; interpret header data and get rest */
+  wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;
+
+  wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;
+
+  /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */
+  wsctx->header.payloadLen = wsctx->header.data->b1 & 0x7f;
+  rfbLog("first header bytes received; opcode=%d lenbyte=%d\n", wsctx->header.opcode, wsctx->header.payloadLen);
+
+  /*
+   * 4.3. Client-to-Server Masking
+   *
+   * The client MUST mask all frames sent to the server.  A server MUST
+   * close the connection upon receiving a frame with the MASK bit set to 0.
+  **/
+  if (!(wsctx->header.data->b1 & 0x80)) {
+    rfbErr("%s: got frame without mask ret=%d\n", __func__, ret);
+    syslog(LOG_ERR, "%s: got frame without mask; ret=%d\n", __func__, ret);
+    errno = EIO;
+    *sockRet = -1;
+    return WS_HYBI_STATE_ERR;
+  }
+
+  if (wsctx->header.payloadLen < 126 && wsctx->nReadRaw >= 6) {
+    wsctx->header.headerLen = 2 + WS_HYBI_MASK_LEN;
+    wsctx->header.mask = wsctx->header.data->u.m;
+  } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->nReadRaw) {
+    wsctx->header.headerLen = 4 + WS_HYBI_MASK_LEN;
+    wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);
+    wsctx->header.mask = wsctx->header.data->u.s16.m16;
+  } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->nReadRaw) {
+    wsctx->header.headerLen = 10 + WS_HYBI_MASK_LEN;
+    wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);
+    wsctx->header.mask = wsctx->header.data->u.s64.m64;
+  } else {
+    /* Incomplete frame header, try again */
+    rfbErr("%s: incomplete frame header; ret=%d\n", __func__, ret);
+    errno = EAGAIN;
+    *sockRet = -1;
+    return WS_HYBI_STATE_HEADER_PENDING;
+  }
+
+  /* absolute length of frame */
+  wsctx->nToRead = wsctx->header.headerLen + wsctx->header.payloadLen;
+
+  /* update write position for next bytes */
+  wsctx->writePos = wsctx->codeBufDecode + wsctx->nReadRaw;
+
+  /* set payload pointer just after header */
+  wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);
+
+  rfbLog("header complete: state=%d flen=%d writeTo=%p\n", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos);
+
+  return WS_HYBI_STATE_DATA_NEEDED;
+}
+
+static int
+hybiWsFrameComplete(ws_ctx_t *wsctx)
+{
+  return wsctx != NULL && hybiRemaining(wsctx) == 0;
+}
+
+static char *
+hybiPayloadStart(ws_ctx_t *wsctx)
+{
+  return wsctx->codeBufDecode + wsctx->header.headerLen;
+}
+
+
+/**
+ * Read the remaining payload bytes from associated raw socket.
+ *
+ *  - try to read remaining bytes from socket
+ *  - unmask all multiples of 4
+ *  - if frame incomplete but some bytes are left, these are copied to
+ *      the carry buffer
+ *  - if opcode is TEXT: Base64-decode all unmasked received bytes
+ *  - set state for reading decoded data
+ *  - reset write position to begin of buffer (+ header)
+ *      --> before we retrieve more data we let the caller clear all bytes
+ *          from the reception buffer
+ *  - execute return data routine
+ *
+ *  Sets errno corresponding to what it gets from the underlying
+ *  socket or EIO if some internal sanity check fails.
+ *
+ *  @param[in]  cl client ptr with raw socket reference
+ *  @param[out] dst  destination buffer
+ *  @param[in]  len  size of destination buffer
+ *  @param[out] sockRet emulated recv return value
+ *  @return next hybi decode state
+ */
+static int
+hybiReadAndDecode(ws_ctx_t *wsctx, char *dst, int len, int *sockRet)
+{
+  int n;
+  int i;
+  int toReturn;
+  int toDecode;
+  int bufsize;
+  int nextRead;
+  unsigned char *data;
+  uint32_t *data32;
+
+  /* if data was carried over, copy to start of buffer */
+  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);
+  wsctx->writePos += wsctx->carrylen;
+
+  /* -1 accounts for potential '\0' terminator for base64 decoding */
+  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;
+  if (hybiRemaining(wsctx) > bufsize) {
+    nextRead = bufsize;
+  } else {
+    nextRead = hybiRemaining(wsctx);
+  }
+
+  rfbLog("calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\n", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);
+
+  if (wsctx->nReadRaw < wsctx->nToRead) {
+    /* decode more data */
+    //if (-1 == (n = ws_read(cl, wsctx->writePos, nextRead))) {
+    if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {
+      int olderrno = errno;
+      rfbErr("%s: read; %s", __func__, strerror(errno));
+      errno = olderrno;
+      *sockRet = -1;
+      return WS_HYBI_STATE_ERR;
+    } else if (n == 0) {
+      *sockRet = 0;
+      return WS_HYBI_STATE_ERR;
+    }
+    wsctx->nReadRaw += n;
+    rfbLog("read %d bytes from socket; nRead=%d\n", n, wsctx->nReadRaw);
+  } else {
+    n = 0;
+  }
+
+  wsctx->writePos += n;
+
+  if (wsctx->nReadRaw >= wsctx->nToRead) {
+    if (wsctx->nReadRaw > wsctx->nToRead) {
+      rfbErr("%s: internal error, read past websocket frame", __func__);
+      errno=EIO;
+      *sockRet = -1;
+      return WS_HYBI_STATE_ERR;
+    }
+  }
+
+  toDecode = wsctx->writePos - hybiPayloadStart(wsctx);
+  rfbLog("toDecode=%d from n=%d carrylen=%d headerLen=%d\n", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);
+  if (toDecode < 0) {
+    rfbErr("%s: internal error; negative number of bytes to decode: %d", __func__, toDecode);
+    errno=EIO;
+    *sockRet = -1;
+    return WS_HYBI_STATE_ERR;
+  }
+
+  /* for a possible base64 decoding, we decode multiples of 4 bytes until
+   * the whole frame is received and carry over any remaining bytes in the carry buf*/
+  data = (unsigned char *)hybiPayloadStart(wsctx);
+  data32= (uint32_t *)data;
+
+  for (i = 0; i < (toDecode >> 2); i++) {
+    data32[i] ^= wsctx->header.mask.u;
+  }
+  rfbLog("mask decoding; i=%d toDecode=%d\n", i, toDecode);
+
+  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {
+    /* process the remaining bytes (if any) */
+    for (i*=4; i < toDecode; i++) {
+      data[i] ^= wsctx->header.mask.c[i % 4];
+    }
+
+    /* all data is here, no carrying */
+    wsctx->carrylen = 0;
+  } else {
+    /* carry over remaining, non-multiple-of-four bytes */
+    wsctx->carrylen = toDecode - (i * 4);
+    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {
+      syslog(LOG_ERR, "%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d", __func__, wsctx->carrylen, toDecode, i);
+      *sockRet = -1;
+      errno = EIO;
+      return WS_HYBI_STATE_ERR;
+    }
+    rfbLog("carrying over %d bytes from %p to %p\n", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);
+    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);
+  }
+
+  toReturn = toDecode - wsctx->carrylen;
+
+  switch (wsctx->header.opcode) {
+    case WS_OPCODE_CLOSE:
+
+      /* this data is not returned as payload data */
+      if (hybiWsFrameComplete(wsctx)) {
+        rfbLog("got closure, reason %d\n", WS_NTOH16(((uint16_t *)data)[0]));
+        rfbLog("got close cmd, reason %d\n", WS_NTOH16(((uint16_t *)data)[0]));
+        errno = ECONNRESET;
+        *sockRet = -1;
+        return WS_HYBI_STATE_FRAME_COMPLETE;
+      } else {
+        rfbErr("%s: close reason with long frame not supported", __func__);
+        errno = EIO;
+        *sockRet = -1;
+        return WS_HYBI_STATE_ERR;
+      }
+      break;
+    case WS_OPCODE_TEXT_FRAME:
+      data[toReturn] = '\0';
+      rfbLog("Initiate Base64 decoding in %p with max size %d and '\\0' at %p\n", data, bufsize, data + toReturn);
+      if (-1 == (wsctx->readlen = __b64_pton((char *)data, data, bufsize))) {
+        syslog(LOG_ERR, "Base64 decode error in %s; data=%p bufsize=%d", __func__, data, bufsize);
+        rfbErr("%s: Base64 decode error; %s\n", __func__, strerror(errno));
+      }
+      wsctx->writePos = hybiPayloadStart(wsctx);
+      break;
+    case WS_OPCODE_BINARY_FRAME:
+      wsctx->readlen = toReturn;
+      wsctx->writePos = hybiPayloadStart(wsctx);
+      rfbLog("set readlen=%d writePos=%p\n", wsctx->readlen, wsctx->writePos);
+      break;
+    default:
+      rfbErr("%s: unhandled opcode %d, b0: %02x, b1: %02x\n", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);
+  }
+  wsctx->readPos = data;
+
+  return hybiReturnData(dst, len, wsctx, sockRet);
+}
+
+/**
+ * Read function for websocket-socket emulation.
+ *
+ *    0                   1                   2                   3
+ *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-------+-+-------------+-------------------------------+
+ *   |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
+ *   |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
+ *   |N|V|V|V|       |S|             |   (if payload len==126/127)   |
+ *   | |1|2|3|       |K|             |                               |
+ *   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
+ *   |     Extended payload length continued, if payload len == 127  |
+ *   + - - - - - - - - - - - - - - - +-------------------------------+
+ *   |                               |Masking-key, if MASK set to 1  |
+ *   +-------------------------------+-------------------------------+
+ *   | Masking-key (continued)       |          Payload Data         |
+ *   +-------------------------------- - - - - - - - - - - - - - - - +
+ *   :                     Payload Data continued ...                :
+ *   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
+ *   |                     Payload Data continued ...                |
+ *   +---------------------------------------------------------------+
+ *
+ * Using the decode buffer, this function:
+ *  - reads the complete header from the underlying socket
+ *  - reads any remaining data bytes
+ *  - unmasks the payload data using the provided mask
+ *  - decodes Base64 encoded text data
+ *  - copies len bytes of decoded payload data into dst
+ *
+ * Emulates a read call on a socket.
+ */
+int
+webSocketsDecodeHybi(ws_ctx_t *wsctx, char *dst, int len)
+{
+    int result = -1;
+    /* int fin; */ /* not used atm */
+
+    /* rfbLog(" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\n", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */
+    rfbLog("%s_enter: len=%d; "
+                      "CTX: readlen=%d readPos=%p "
+                      "writeTo=%p "
+                      "state=%d toRead=%d remaining=%d "
+                      " nReadRaw=%d carrylen=%d carryBuf=%p\n",
+                      __func__, len,
+                      wsctx->readlen, wsctx->readPos,
+                      wsctx->writePos,
+                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),
+                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf);
+
+    switch (wsctx->hybiDecodeState){
+      case WS_HYBI_STATE_HEADER_PENDING:
+        wsctx->hybiDecodeState = hybiReadHeader(wsctx, &result);
+        if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {
+          goto spor;
+        }
+        if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {
+
+          /* when header is complete, try to read some more data */
+          wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result);
+        }
+        break;
+      case WS_HYBI_STATE_DATA_AVAILABLE:
+        wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);
+        break;
+      case WS_HYBI_STATE_DATA_NEEDED:
+        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result);
+        break;
+      case WS_HYBI_STATE_CLOSE_REASON_PENDING:
+        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result);
+        break;
+      default:
+        /* invalid state */
+        rfbErr("%s: called with invalid state %d\n", wsctx->hybiDecodeState);
+        result = -1;
+        errno = EIO;
+        wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;
+    }
+
+    /* single point of return, if someone has questions :-) */
+spor:
+    /* rfbLog("%s: ret: %d/%d\n", __func__, result, len); */
+    if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {
+      rfbLog("frame received successfully, cleaning up: read=%d hlen=%d plen=%d\n", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);
+      /* frame finished, cleanup state */
+      hybiDecodeCleanup(wsctx);
+    } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {
+      hybiDecodeCleanup(wsctx);
+    }
+    rfbLog("%s_exit: len=%d; "
+                      "CTX: readlen=%d readPos=%p "
+                      "writePos=%p "
+                      "state=%d toRead=%d remaining=%d "
+                      "nRead=%d carrylen=%d carryBuf=%p "
+                      "result=%d\n",
+                      __func__, len,
+                      wsctx->readlen, wsctx->readPos,
+                      wsctx->writePos,
+                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),
+                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf,
+                      result);
+    return result;
+}
diff --git a/libvncserver/ws_decode.h b/libvncserver/ws_decode.h
new file mode 100644
index 0000000..9ed5b11
--- /dev/null
+++ b/libvncserver/ws_decode.h
@@ -0,0 +1,125 @@
+#ifndef _WS_DECODE_H_
+#define _WS_DECODE_H_
+
+#include <stdint.h>
+#include <rfb/rfb.h>
+#ifndef _MSC_VER
+#include <resolv.h> /* __b64_ntop */
+#endif
+
+enum {
+  WEBSOCKETS_VERSION_HIXIE,
+  WEBSOCKETS_VERSION_HYBI
+};
+
+#define WSHLENMAX 14  /* 2 + sizeof(uint64_t) + sizeof(uint32_t) */
+#define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)
+
+#define WS_NTOH64(n) htobe64(n)
+#define WS_NTOH32(n) htobe32(n)
+#define WS_NTOH16(n) htobe16(n)
+#define WS_HTON64(n) htobe64(n)
+#define WS_HTON16(n) htobe16(n)
+
+#define ARRAYSIZE(a) ((sizeof(a) / sizeof((a[0]))) / (size_t)(!(sizeof(a) % sizeof((a[0])))))
+
+struct ws_ctx_s;
+typedef struct ws_ctx_s ws_ctx_t;
+
+typedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);
+typedef int (*wsDecodeFunc)(ws_ctx_t *wsctx, char *dst, int len);
+
+typedef int (*wsReadFunc)(void *ctx, char *dst, int len);
+
+typedef struct ctxInfo_s{
+  void *ctxPtr;
+  wsReadFunc readFunc;
+} ctxInfo_t;
+
+enum {
+  /* header not yet received completely */
+  WS_HYBI_STATE_HEADER_PENDING,
+  /* data available */
+  WS_HYBI_STATE_DATA_AVAILABLE,
+  WS_HYBI_STATE_DATA_NEEDED,
+  /* received a complete frame */
+  WS_HYBI_STATE_FRAME_COMPLETE,
+  /* received part of a 'close' frame */
+  WS_HYBI_STATE_CLOSE_REASON_PENDING,
+  /* */
+  WS_HYBI_STATE_ERR
+};
+
+typedef union ws_mask_s {
+  char c[4];
+  uint32_t u;
+} ws_mask_t;
+
+/* XXX: The union and the structs do not need to be named.
+ *      We are working around a bug present in GCC < 4.6 which prevented
+ *      it from recognizing anonymous structs and unions.
+ *      See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4784
+ */
+typedef struct __attribute__ ((__packed__)) ws_header_s {
+  unsigned char b0;
+  unsigned char b1;
+  union {
+    struct __attribute__ ((__packed__)) {
+      uint16_t l16;
+      ws_mask_t m16;
+    } s16;
+    struct __attribute__ ((__packed__)) {
+      uint64_t l64;
+      ws_mask_t m64;
+    } s64;
+    ws_mask_t m;
+  } u;
+} ws_header_t;
+
+typedef struct ws_header_data_s {
+  ws_header_t *data;
+  /** bytes read */
+  int nRead;
+  /** mask value */
+  ws_mask_t mask;
+  /** length of frame header including payload len, but without mask */
+  int headerLen;
+  /** length of the payload data */
+  int payloadLen;
+  /** opcode */
+  unsigned char opcode;
+} ws_header_data_t;
+
+typedef struct ws_ctx_s {
+    char codeBufDecode[2048 + WSHLENMAX]; /* base64 + maximum frame header length */
+    char codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */
+    char *writePos;
+    unsigned char *readPos;
+    int readlen;
+    int hybiDecodeState;
+    char carryBuf[3];                      /* For base64 carry-over */
+    int carrylen;
+    int version;
+    int base64;
+    ws_header_data_t header;
+    int nReadRaw;
+    int nToRead;
+    wsEncodeFunc encode;
+    wsDecodeFunc decode;
+    ctxInfo_t ctxInfo;
+} ws_ctx_t;
+
+enum
+{
+    WS_OPCODE_CONTINUATION = 0x0,
+    WS_OPCODE_TEXT_FRAME,
+    WS_OPCODE_BINARY_FRAME,
+    WS_OPCODE_CLOSE = 0x8,
+    WS_OPCODE_PING,
+    WS_OPCODE_PONG
+};
+
+int webSocketsDecodeHybi(ws_ctx_t *wsctx, char *dst, int len);
+
+void hybiDecodeCleanup(ws_ctx_t *wsctx);
+#endif
diff --git a/test/Makefile.am b/test/Makefile.am
index f07fc82..73fa83f 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -10,7 +10,13 @@ tjbench_SOURCES=tjbench.c ../common/turbojpeg.c ../common/turbojpeg.h \
 tjbench_LDADD=$(LDADD) -lm
 endif
 
-AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/common
+# websocket frame decode tests
+check_PROGRAMS += wshybitest
+wshybitest_SOURCES=wshybitest.c ../libvncserver/ws_decode.c ../libvncserver/ws_decode.h
+
+
+
+AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/common -I$(top_srcdir)/libvncserver
 LDADD = ../libvncserver/libvncserver.la ../libvncclient/libvncclient.la @WSOCKLIB@
 
 if HAVE_LIBPTHREAD
@@ -23,6 +29,7 @@ copyrecttest_LDADD=$(LDADD) -lm
 check_PROGRAMS += $(ENCODINGS_TEST) cargstest copyrecttest $(BACKGROUND_TEST) \
 	cursortest
 
-test: encodingstest$(EXEEXT) cargstest$(EXEEXT) copyrecttest$(EXEEXT)
-	./encodingstest && ./cargstest
+all: encodingstest$(EXEEXT) cargstest$(EXEEXT) copyrecttest$(EXEEXT) wshybitest$(EXEEXT) tjunittest$(EXEXT)
+	./wshybitest
+#./encodingstest && ./cargstest
 
