diff -up crda-3.18/Makefile.pycrypto crda-3.18/Makefile
--- crda-3.18/Makefile.pycrypto	2019-09-23 17:09:32.577420391 +0200
+++ crda-3.18/Makefile	2019-09-23 17:09:50.400490612 +0200
@@ -112,7 +112,7 @@ $(REG_BIN):
 keys-%.c: utils/key2pub.py $(wildcard $(PUBKEY_DIR)/*.pem)
 	$(NQ) '  GEN ' $@
 	$(NQ) '  Trusted pubkeys:' $(wildcard $(PUBKEY_DIR)/*.pem)
-	$(Q)./utils/key2pub.py --$* $(wildcard $(PUBKEY_DIR)/*.pem) $@
+	$(Q) python utils/key2pub.py --$* $(wildcard $(PUBKEY_DIR)/*.pem) $@
 
 $(LIBREG): reglib.c
 	$(NQ) '  CC  ' $@
diff -up crda-3.18/utils/key2pub.py.pycrypto crda-3.18/utils/key2pub.py
--- crda-3.18/utils/key2pub.py.pycrypto	2019-09-23 17:09:32.713420926 +0200
+++ crda-3.18/utils/key2pub.py	2019-09-23 17:10:41.306691165 +0200
@@ -1,80 +1,77 @@
 #!/usr/bin/env python
 
+import io
 import sys
 try:
-       from M2Crypto import RSA
-except ImportError, e:
-       sys.stderr.write('ERROR: Failed to import the "M2Crypto" module: %s\n' % e.message)
-       sys.stderr.write('Please install the "M2Crypto" Python module.\n')
-       sys.stderr.write('On Debian GNU/Linux the package is called "python-m2crypto".\n')
-       sys.exit(1)
-
+    from Crypto.PublicKey import RSA
+except ImportError as e:
+    sys.stderr.write('ERROR: Failed to import the "Crypto.PublicKey" module: %s\n' % e.message)
+    sys.stderr.write('Please install the "Crypto.PublicKey" Python module.\n')
+    sys.stderr.write('On Debian GNU/Linux the package is called "python-crypto".\n')
+    sys.exit(1)
+
+def bitwise_collect(value, radix_bits):
+    words = []
+    radix_mask = (1 << radix_bits) - 1
+    while value != 0:
+        words.append(value & radix_mask)
+        value >>= radix_bits
+    return words
+ 
 def print_ssl_64(output, name, val):
-    while val[0] == '\0':
-        val = val[1:]
-    while len(val) % 8:
-        val = '\0' + val
-    vnew = []
-    while len(val):
-        vnew.append((val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7]))
-        val = val[8:]
-    vnew.reverse()
-    output.write('static BN_ULONG %s[%d] = {\n' % (name, len(vnew)))
+    # OpenSSL expects 64-bit words given least-significant-word first.
+    vwords = bitwise_collect(val, 64)
+
+    output.write(u'static BN_ULONG {}[] = {{\n'.format(name))
     idx = 0
-    for v1, v2, v3, v4, v5, v6, v7, v8 in vnew:
+    for vword in vwords:
         if not idx:
-            output.write('\t')
-        output.write('0x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2xULL, ' % (ord(v1), ord(v2), ord(v3), ord(v4), ord(v5), ord(v6), ord(v7), ord(v8)))
+            output.write(u'\t')
+        output.write(u'0x{:016x}ULL, '.format(vword))
         idx += 1
         if idx == 2:
             idx = 0
-            output.write('\n')
+            output.write(u'\n')
     if idx:
-        output.write('\n')
-    output.write('};\n\n')
+        output.write(u'\n')
+    output.write(u'};\n\n')
 
 def print_ssl_32(output, name, val):
-    while val[0] == '\0':
-        val = val[1:]
-    while len(val) % 4:
-        val = '\0' + val
-    vnew = []
-    while len(val):
-        vnew.append((val[0], val[1], val[2], val[3], ))
-        val = val[4:]
-    vnew.reverse()
-    output.write('static BN_ULONG %s[%d] = {\n' % (name, len(vnew)))
+    # OpenSSL expects 32-bit words given least-significant-word first.
+    vwords = bitwise_collect(val, 32)
+
+    output.write(u'static BN_ULONG {}[] = {{\n'.format(name))
     idx = 0
-    for v1, v2, v3, v4 in vnew:
+    for vword in vwords:
         if not idx:
-            output.write('\t')
-        output.write('0x%.2x%.2x%.2x%.2x, ' % (ord(v1), ord(v2), ord(v3), ord(v4)))
+            output.write(u'\t')
+        output.write(u'0x{:08x}, '.format(vword))
         idx += 1
         if idx == 4:
             idx = 0
-            output.write('\n')
+            output.write(u'\n')
     if idx:
-        output.write('\n')
-    output.write('};\n\n')
+        output.write(u'\n')
+    output.write(u'};\n\n')
 
 def print_ssl(output, name, val):
     import os
-    output.write('#include <stdint.h>\n')
-    output.write('#include <openssl/bn.h>\n')
+    output.write(u'#include <stdint.h>\n')
+    output.write(u'#include <openssl/bn.h>\n')
     if os.getenv('TARGET_BITS') == '64':
         return print_ssl_64(output, name, val)
     else:
         return print_ssl_32(output, name, val)
 
 def print_ssl_keys(output, n):
-    output.write(r'''
+    output.write(u'''
 struct pubkey {
 	struct bignum_st e, n;
 };
 
-#define KEY(data) {				\
-	.d = data,				\
-	.top = sizeof(data)/sizeof(data[0]),	\
+#define KEY(data) {				\\
+	.d = data,				\\
+	.top = sizeof(data)/sizeof(data[0]),	\\
 }
 
 #define KEYS(e,n)	{ KEY(e), KEY(n), }
@@ -82,46 +79,48 @@ struct pubkey {
 static struct pubkey keys[] __attribute__((unused))= {
 ''')
     for n in xrange(n + 1):
-        output.write('	KEYS(e_%d, n_%d),\n' % (n, n))
-    output.write('};\n')
+        output.write(u'	KEYS(e_{0}, n_{0}),\n'.format(n))
+    output.write(u'};\n')
     pass
 
 def print_gcrypt(output, name, val):
-    output.write('#include <stdint.h>\n')
-    while val[0] == '\0':
-        val = val[1:]
-    output.write('static const uint8_t %s[%d] = {\n' % (name, len(val)))
+    # gcrypt expects 8-bit words most-significant-word first
+    vwords = bitwise_collect(val, 8)
+    vwords.reverse()
+
+    output.write(u'#include <stdint.h>\n')
+    output.write(u'static const uint8_t %s[%d] = {\n' % (name, len(vwords)))
     idx = 0
-    for v in val:
+    for vword in vwords:
         if not idx:
-            output.write('\t')
-        output.write('0x%.2x, ' % ord(v))
+            output.write(u'\t')
+        output.write(u'0x{:02x}, '.format(vword))
         idx += 1
         if idx == 8:
             idx = 0
-            output.write('\n')
+            output.write(u'\n')
     if idx:
-        output.write('\n')
-    output.write('};\n\n')
+        output.write(u'\n')
+    output.write(u'};\n\n')
 
 def print_gcrypt_keys(output, n):
-    output.write(r'''
+    output.write(u'''
 struct key_params {
 	const uint8_t *e, *n;
 	uint32_t len_e, len_n;
 };
 
-#define KEYS(_e, _n) {			\
-	.e = _e, .len_e = sizeof(_e),	\
-	.n = _n, .len_n = sizeof(_n),	\
+#define KEYS(_e, _n) {			\\
+	.e = _e, .len_e = sizeof(_e),	\\
+	.n = _n, .len_n = sizeof(_n),	\\
 }
 
 static const struct key_params keys[] __attribute__((unused))= {
 ''')
-    for n in xrange(n + 1):
-        output.write('	KEYS(e_%d, n_%d),\n' % (n, n))
-    output.write('};\n')
-    
+    for n in range(n + 1):
+        output.write(u'	KEYS(e_{0}, n_{0}),\n'.format(n))
+    output.write(u'};\n')
+
 
 modes = {
     '--ssl': (print_ssl, print_ssl_keys),
@@ -136,21 +135,21 @@ except IndexError:
     mode = None
 
 if not mode in modes:
-    print 'Usage: %s [%s] input-file... output-file' % (sys.argv[0], '|'.join(modes.keys()))
+    print('Usage: {} [{}] input-file... output-file'.format(sys.argv[0], '|'.join(modes.keys())))
     sys.exit(2)
 
-output = open(outfile, 'w')
+output = io.open(outfile, 'w')
 
 # load key
 idx = 0
 for f in files:
-    try:
-        key = RSA.load_pub_key(f)
-    except RSA.RSAError:
-        key = RSA.load_key(f)
 
-    modes[mode][0](output, 'e_%d' % idx, key.e[4:])
-    modes[mode][0](output, 'n_%d' % idx, key.n[4:])
+    key_contents = io.open(f, 'rb').read()
+    key = RSA.importKey(key_contents)
+
+    modes[mode][0](output, 'e_{}'.format(idx), key.e)
+    modes[mode][0](output, 'n_{}'.format(idx), key.n)
+
     idx += 1
 
 modes[mode][1](output, idx - 1)
